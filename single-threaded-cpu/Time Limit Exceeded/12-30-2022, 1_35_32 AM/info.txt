{"id":867630993,"question_id":1962,"lang":"cpp","lang_name":"C++","time":"1 year, 2 months","timestamp":1672335332,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/867630993/","is_pending":"Not Pending","title":"Single-Threaded CPU","memory":"N/A","code":"struct task{\n    vector<int> time;\n    int num;\n    task(vector<int> time, int num):time(time), num(num){};\n};\nstatic bool cmp(task a, task b){\n    if(a.time[0] != b.time[0])return a.time[0] < b.time[0];\n    return a.time[1] < b.time[1];\n}\nbool operator < (task a, task b){\n    if(a.time[1] != b.time[1]) return a.time[1] > b.time[1];\n    return a.num > b.num;\n}\n\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        vector<task> T;\n        for(int i = 0; i < tasks.size(); i++){\n            T.push_back(task(tasks[i], i));\n        }\n        sort(T.begin(), T.end(), cmp);\n        vector<int> ans;\n        int idx = 1;\n        int curTime = T[0].time[0];\n        priority_queue<task> q; q.push(T[0]);\n        while(!q.empty()){\n            auto top = q.top(); q.pop(); \n            ans.push_back(top.num);\n            curTime = min(1000000000, max(top.time[0], curTime) + top.time[1]);\n            while(idx < T.size() && (q.empty() || curTime >= T[idx].time[0])){\n                q.push(T[idx++]);\n            }\n        }\n        return ans;\n    }\n};","compare_result":"111111111111111111111111111110000000000","title_slug":"single-threaded-cpu","has_notes":false,"flag_type":1}