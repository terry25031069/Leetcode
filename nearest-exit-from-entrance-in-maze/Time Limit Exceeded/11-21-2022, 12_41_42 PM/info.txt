{"id":847249697,"question_id":2038,"lang":"cpp","lang_name":"C++","time":"1 year, 3 months","timestamp":1669005702,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/847249697/","is_pending":"Not Pending","title":"Nearest Exit from Entrance in Maze","memory":"N/A","code":"class Solution {\npublic:\n    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {\n        int visit[101][101] = {};\n        entrance.push_back(0);\n        queue<vector<int>>q; q.push(entrance);\n        while(!q.empty()){\n            auto top = q.front(); q.pop();\n            int x = top[0], y = top[1], step = top[2];\n            visit[x][y] = 1;\n            int dx[] = {0, 1, 0, -1},  dy[] = {1, 0, -1, 0};\n            for(int k = 0; k < 4; k++){\n                int kx = x + dx[k], ky = y + dy[k];\n                if(kx > -1 && kx < maze.size() && ky > -1 && ky < maze[0].size() && maze[kx][ky] == '.' && visit[kx][ky] == 0){\n                    //cout << kx << ' ' << ky << endl;\n                    if(kx == 0 || kx == maze.size() - 1 || ky == 0 || ky == maze[0].size() - 1) return step + 1;\n                    q.push(vector<int>{kx, ky, step + 1});\n                }\n            }\n        }\n        return -1;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000","title_slug":"nearest-exit-from-entrance-in-maze","has_notes":false,"flag_type":1}