{"id":1185064937,"question_id":2213,"lang":"cpp","lang_name":"C++","time":"2 weeks, 2 days","timestamp":1708799164,"status":10,"status_display":"Accepted","runtime":"436 ms","url":"/submissions/detail/1185064937/","is_pending":"Not Pending","title":"Find All People With Secret","memory":"161 MB","code":"class UnionFind {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    UnionFind(int n) {\n        // Initialize parent and rank arrays\n        parent.resize(n);\n        rank.resize(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        // Find parent of node x. Use Path Compression\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        // Unite two nodes x and y, if they are not already united\n        int px = find(x);\n        int py = find(y);\n        if (px != py) {\n            // Union by Rank Heuristic\n            if (rank[px] > rank[py]) {\n                parent[py] = px;\n            } else if (rank[px] < rank[py]) {\n                parent[px] = py;\n            } else {\n                parent[py] = px;\n                rank[px] += 1;\n            }\n        }\n    }\n\n    bool connected(int x, int y) {\n        // Check if two nodes x and y are connected or not\n        return find(x) == find(y);\n    }\n\n    void reset(int x) {\n        // Reset the initial properties of node x\n        parent[x] = x;\n        rank[x] = 0;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\n        // Sort meetings in increasing order of time\n        sort(meetings.begin(), meetings.end(), [](auto& a, auto& b) {\n            return a[2] < b[2];\n        });\n\n        // Group Meetings in increasing order of time\n        map<int, vector<pair<int, int>>> sameTimeMeetings;\n        for (auto& meeting : meetings) {\n            int x = meeting[0], y = meeting[1], t = meeting[2];\n            sameTimeMeetings[t].emplace_back(x, y);\n        }\n    \n        // Create graph\n        UnionFind graph(n);\n        graph.unite(firstPerson, 0);\n\n        // Process in increasing order of time\n        for (auto& [t, meetings] : sameTimeMeetings) {\n            // Unite two persons taking part in a meeting\n            for (auto& [x, y] : meetings) {\n                graph.unite(x, y);\n            }\n            \n            // If any one knows the secret, both will be connected to 0.\n            // If no one knows the secret, then reset.\n            for (auto& [x, y] : meetings) {\n                if (!graph.connected(x, 0)) {\n                    // No need to check for y since x and y were united\n                    graph.reset(x);\n                    graph.reset(y);\n                }\n            }\n        }\n        \n        // Al those who are connected to 0 will know the secret\n        vector<int> ans;\n        for (int i = 0; i < n; ++i) {\n            if (graph.connected(i, 0)) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"find-all-people-with-secret","has_notes":false,"flag_type":1}